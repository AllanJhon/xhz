package com.sjz.zyl.appdemo.utils;import android.content.Context;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.Canvas;import android.graphics.drawable.BitmapDrawable;import android.graphics.drawable.Drawable;import android.os.AsyncTask;import android.text.Html;import android.util.Log;import android.view.View;import java.io.IOException;import java.io.InputStream;import java.net.URI;import java.net.URL;/** * Description * * @author by 张迎乐(yingle1991@gmail.com) * @since 2018-02-14. */public class HtmlRemoteImageGetter implements Html.ImageGetter {    Context c;    View container;    URI baseUri;    /**     * Construct the URLImageParser which will execute AsyncTask and refresh the container     */    public HtmlRemoteImageGetter(View t, Context c, String baseUrl) {        this.c = c;        this.container = t;        if (baseUrl != null) {            this.baseUri = URI.create(baseUrl);        }    }    public Drawable getDrawable(String source) {        UrlDrawable urlDrawable = new UrlDrawable();        ImageGetterAsyncTask asyncTask = new ImageGetterAsyncTask(urlDrawable);        asyncTask.execute(source);        // return reference to URLDrawable which will asynchronously load the image specified in the src tag        return urlDrawable;    }    public class ImageGetterAsyncTask extends AsyncTask<String, Void, Drawable> {        UrlDrawable urlDrawable;        String source;        public ImageGetterAsyncTask(UrlDrawable d) {            this.urlDrawable = d;        }        @Override        protected void onPreExecute() {            super.onPreExecute();        }        @Override        protected void onPostExecute(final Drawable result) {            if (result == null) {                Log.w("HtmlTextView", "Drawable result is null! (source: " + source + ")");                return;            }            // set the correct bound according to the result from HTTP call//            urlDrawable.setBounds(0, 0, 0 + result.getIntrinsicWidth(), 0 + result.getIntrinsicHeight());            // change the reference of the current drawable to the result from the HTTP call            urlDrawable.drawable = result;            // redraw the image by invalidating the container            urlDrawable.invalidateSelf();            HtmlRemoteImageGetter.this.container.invalidate();            // important//            ((HtmlTextView)container).setText(((HtmlTextView) container).getText());//            </span>        }        @Override        protected Drawable doInBackground(String... params) {            source = params[0];            return fetchDrawable(source);        }        /**         * Get the Drawable from URL         */        public Drawable fetchDrawable(String urlString) {            try {                InputStream is = fetch(urlString);                Bitmap bitmap= BitmapFactory.decodeStream(is);                Drawable drawable = new BitmapDrawable(c.getResources(), bitmap);                int width = bitmap.getWidth();                int height = bitmap.getHeight();                int newWidth = width;                int newHeight = height;                if( width > container.getWidth() ) {                    newWidth = container.getWidth();                    newHeight = (newWidth * height) / width;                }                drawable.setBounds(0, 0, 0 + newWidth, 0 + newHeight);                urlDrawable.setBounds(0, 0, newWidth, newHeight);                return drawable;            } catch (Exception e) {                return null;            }        }        private InputStream fetch(String urlString) throws IOException {            URL url;            if (baseUri != null) {                url = baseUri.resolve(urlString).toURL();            } else {                url = URI.create(urlString).toURL();            }            return (InputStream) url.getContent();        }    }    @SuppressWarnings("deprecation")    public class UrlDrawable extends BitmapDrawable {        protected Drawable drawable;        @Override        public void draw(Canvas canvas) {            // override the draw to facilitate refresh function later            if (drawable != null) {                drawable.draw(canvas);            }        }    }}